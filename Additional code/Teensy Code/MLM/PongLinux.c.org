/*
 * Title: LEDdataSend4-osc.c
 *
 * Author: Alistair Riddell
 *
 * DoC: Mon  4 Jan 2016 16:02:09 AEDT 
 *
 * DLM: Tue 26 Jan 2016 10:27:40 AEDT 
 *
 * SETUP
 *
 * USB installation (should be automatic)
 *
 * 		1. Mad Catz (hidraw0)
 * 		2. Mad Catz (hidraw1)
 * 		3. Left Teensy Controller (ttyACM0)
 * 		4. Right Teensy Controller (ttyACM1)
 * 		Teensys now auto allocated through libudev
 *
 * Comments
 * 			To send data to Teensy3.1 to drive LEDs
 * 			Working. Fri 13 Mar 2015 11:43:46 AEDT
 * 			Now to do the timing from here.
 *			Transmission is slow but it is probably at the Teensy side. Not sure what to do about that.
 *			It's certainly not as fast as desired.
 *			The BAUDRATE has been up'd but I don't think that matters as the USB is fixed at 12Mb/s.
 *
 * 			OK. Now the Joystick is working here. Need to figure out what input to map to what output.
 * 			Also, can two Joysticks work? Don't know yet.
 *
 * 			Mon 26 Oct 2015 10:58:28 AEDT
 * 			Second Joystick can be added. Params different but that was expected.
 * 			Use hidraw0 and hidraw1
 *
 * 			Sun 15 Nov 2015 10:50:58 AEDT
 * 			Start tests on sending complete frame data to screen
 *			Added map function for xy joystick movement conversion
 *
 * 			Mon 16 Nov 20ed xy joystick send data...not working yet.
 *
 * 			Wed 18 Nov 2015 06:31:50 AEDT
 * 			XY data sending should be working through table lookup.
 * 			It should be activated through Trigger on
 * 			Working
 *
 * 			Thu 26 Nov 2015 11:05:48 AEDT
 * 			JS control of LEDs seems to hit an end point around 1000 and doesn't go beyond that.
 * 			Not sure what the problem is but the integer conversion and transfer over USB seems fine.
 * 			Solved. Had to increase the conversion/transfer size from 4 to 5. Must have been converting to a value of 3 bytes instead of 4.
 * 			Code was changed on the Teensy side also.
 *
 * 			Thu 26 Nov 2015 12:57:03 AEDT
 * 			What was planned for this stage of development has been achieved and the system functions as expected.
 * 			However, the SELF joystick is less smooth and controllable than the Thrustmaster which is disappointing.
 *
 * 			Sun 13 Dec 2015 22:01:30 AEDT
 * 			2 Major modifications
 * 			1. Switch into auto run mode on inactivity time out
 * 			2. Allow each joystick to control ALL LEDs.
 *
 * 			Mon 14 Dec 2015 10:48:05 AEDT
 * 			Each JS now working across ALL LEDs. Needs more testing though.
 * 			Auto run now working. Set to start after 1 minute of inactivity
 * 			Modified Teensy code too to stabilize colour generation.
 * 			Now only changes on clear screen.
 *
 * 			Tue 15 Dec 2015 11:28:42 AEDT
 * 			Added random clear screen function
 *
 *			Fri 25 Dec 2015 12:02:06 AEDT
 *			Look into simplifying USB connections. In otherwords, it doesn't matter which device is plugged in when.
 *			First, use simmilar Joysticks. Currently thinking about Thrustmaster "Mat Catz", perhaps even 3 Joysticks now.
 *
 * 			Sun 27 Dec 2015 12:53:50 AEDT
 * 			Added udev code to check what device has been mounted and where.
 * 			The object here is to eliminate the need to specifically plug in devices in a particular order
 * 			udev code is not currently active
 *
 * 			Mon  4 Jan 2016 16:02:09 AEDT
 * 			Added new Joystick (Mad Catz). Not yet connected to Teensy output.
 *
 * 			Tue  5 Jan 2016 14:27:13 AEDT
 * 			Got Mad Catz Joystick working.
 * 			Also, using Throttle lever to determine which half of screen buttons write to. If > 127, right else left
 * 			MondrianLike code working. Perhaps needs to be a bit more dense.
 * 			Not entirely comfortable with the pinkie button on Mad Catz joystick for light threading. Trigger still feels a better option.
 * 			However, pinkie button more easily accessed. Trigger button for screen clearing is more easily access often inappropriately.
 *
 * 			Wed  6 Jan 2016 20:14:00 AEDT
 * 			Still thinking about the Z rotation and clear screen.
 * 			I'm thinking that Z might determine Hue or brightness but Z rotation is physically challenging during general JS operation.
 * 			Z rotation could replace Throttle lever but would have to be independent of X,Y movement with pinkie ON state.
 * 			I'll think about it...
 * 			Today, the Teensy code was revised to use the FastLED library but needed to implement a clearScreen() as no other option worked.
 * 			Some functions now look better after revision of the code.
 *
 * 			Using the same type/brand of JS will solve part of the plug in problem as it wont matter which JS is plugged in when.
 * 			Hopefully, libudev might be useful in solving the same problem when the teensy are up.
 * 			For example, /dev/ttyACM0 will be the teensy on the left and so, port. port2 will be right half.
 *
 * 			Fri  8 Jan 2016 13:37:03 AEDT
 * 			Made changes for Mad Catz and SELF JS functionality. Working OK now but will be revised again.
 * 			Added in libudev code to sort out teensy screen order connection.
 *
 * 			Fri  8 Jan 2016 14:51:23 AEDT
 * 			udev now working to sort out teensy connection order.
 *
 * 			Now need to clean up this code!
 *
 * 			Mon 11 Jan 2016 11:20:56 AEDT
 *			Should Throttle lever control something like color/brightness/hue for some/all button patterns?
 *
 *			Fri 15 Jan 2016 18:49:02 AEDT
 *			Throttle brightness not tested yet.
 *			Added OSC control output in this version.
 *			Ordered second Mad Catz JS
 *			Duplicated thread code for it in this version
 *
 *			Sun 24 Jan 2016 14:58:54 AEDT
 *			Added error handling for unidentified Teensy controller.
 *			Program didn't terminate as it should have if a Teensy wasn't correctly identified and allocated the right device id.
 *
 *			Sun 24 Jan 2016 15:06:08 AEDT
 *			Note DON'T send OSC date during autorun? No I'm thinking it should be sent but with different OSC tags.
 *			Also, thinking that "clear screen" shouldn't be Trigger and that screen select shouldn't be JS rotation. But where would they go?
 *			Screen position could be automatically determined through the action of light tracing. The active screen is where JS control last was.
 *			OK, that was a trivial change.
 *			Now what does Rotation do?
 *
 * 			Tue 26 Jan 2016 10:27:40 AEDT
 * 			Version running for OSC testing.
 * 			Should be identical to non-osc current version 3.
 *
 * 			OSC working with Richie's PD audio patches
 *
 * 			Mon  1 Feb 2016 11:48:22 AEDT
 * 			Thinned OSC sends for JS rotation.
 *
 * 			Wed  3 Feb 2016 12:54:23 AEDT
 * 			Back lower JS button now only works if Trigger is *NOT* ON.
 *
 * 			Added complete screen clear as well as individual halves as it currently is.
*/

#include <pthread.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/ioctl.h>
#include <fcntl.h>
#include <termios.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <time.h>
#include <signal.h>
#include <usb.h>
#include <libudev.h>
#include <locale.h>
#include <inttypes.h>
#include "liblo-0.28/lo/lo.h"

#define DEVICE_CNT 2

char *udevnames[]  = {"ttyACM0", "ttyACM1"};
//const char *serial_nums[]  = {"828800", "1369580"}; // Serial numbers of other Teensys
//const char *serial_nums[]  = {"462150", "532430"}; // Serial numbers of Teensys used for light canvas
const char *serial_nums[]  = {"461880", "532430"}; // Serial numbers of Teensys used for light canvas
//const char *serial_nums[]  = {"828800", "532430"}; // Serial numbers of Teensys used for light canvas
const char *serial_num;
const char *dev_node;

#define FALSE 0
#define TRUE 1
#define IDLETIME 1
//#define BAUDRATE B38400
#define BAUDRATE B115200
#define ledsPerLine 90
#define ledsPerLineEnd ledsPerLine-1
#define lines  32
#define maxLeds ledsPerLine*lines

// inlining may be faster
//#define RangeConvf(X, x1, x2, y1, y2) (((float)((X - x1) * (y2 - y1)) / (x2 - x1)) + y1)
//#define RangeConv(X, x1, x2, y1, y2) ((((X - x1) * (y2 - y1)) / (x2 - x1)) + y1)

//const int Mcolours[4] = {0xFF0000,0x0000FF,0xFFFF00, 0xFFFFFF};
//const int rows = 8; // number of actual strips

void signal_callback_handler(int);

//void delay (int milliseconds);
//int urandom();
int udev_assignment ( void );
int randn(int min_num, int max_num);
inline int map(int, int, int, int, int);
//void init_comms(void);
int init_comms1(const char *);
int init_comms2(const char *);
int init_joystick1(void);
int init_joystick2(void);
void init_threads(void);
void build_data(void);
void LedsUp1b(int, int, unsigned char *);
//void dimSend (int, uint8_t);
//void LedsUp2b(int, int, unsigned char *);
void LedsUp1(int);
void LedsUp2(int);
void init_matrix(void);
void msleep(int);
void autoRun(void);
int udev_check (void);

// Thread Functions
void * js1_thread( void * arg );
void * js2_thread( void * arg );
void * minute_thread1(void * arg);
void * minute_thread2(void * arg);

const int totalLeds = ledsPerLine*lines*4;
volatile int STOP=FALSE;
struct termios oldtio,oldtio2, newtio, newtio2;

char devpath[14];
char devpath2[14];
char jdevpath[12] = "/dev/hidraw0";
char jdevpath2[12] = "/dev/hidraw1";
char *usbdevname;
char *usbdevname2;
char *udevname;

// Checking the serial numbers of the Teensys might enable correct assignment to the Joysticks, etc. Need to test this.
//serial: 828800
//serial: 1369580

int Lmatrix[lines][ledsPerLine];
//int drawingMemory[ledsPerStrip*6];

// Threads
pthread_t js1thread;
pthread_t js2thread;
pthread_t min1thread;
pthread_t min2thread;

int js1, js2, mt1, mt2;

int port, port2, jfd, jfd2; // Devices
int b, c, x, y, j, q, r;
int m1, m2, jsize, jsize2, tick1 = 0, tick2 = 0, tick3 = 0;
int autorun = FALSE; // Auto run state.
int multiRows[6];
int multiCols[6];
int finish = FALSE;

char jchar[8];
char jchar2[6];

unsigned char colour;
unsigned char buf[3];
unsigned char buf2[3];
unsigned char led1buf[5];
unsigned char led2buf[5];
unsigned char formbuf1[5];
unsigned char ledIdbuf1[5];
unsigned char formbuf2[6];
unsigned char ledIdbuf2[6];
uint8_t dimBuf[1];

lo_address t;

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  main
 *  Description:
 * =====================================================================================
 */
int
main ( int argc, char *argv[] )
{
time_t tt;

/*  Intializes random number generator */
	srand((unsigned) time(&tt));

//srand(time(NULL));
//	printf("%s %s \n", argv[0], argv[1]);
//

//	this sorts out teensy connection order for screen control
//  set up all communications to Teensy 3.1s from this call too
//	 udev_assignment();
	if(udev_assignment() != 0 ) {
		printf("***************************\n");
		printf("Not all Teensys found.\n"
		"Check that Teensys are powered up\n"
		"and have the correct Serial Numbers defined.\n"
		"Exited\n");
		printf("***************************\n");
		exit(-1);
	 }

/*  build a blob object from some data - not sure I'll use this*/
//    lo_blob btest = lo_blob_new(sizeof(testdata), testdata);
	   
/*  an address to send messages to. sometimes it is better to let the server
    pick a port number for you by passing NULL as the last argument.
	Args:
		host 	An IP address or number, or NULL for the local machine.
		port 	a decimal port number or service name.
	*/
//    lo_address t = lo_address_new_from_url( "osc.unix://localhost/tmp/mysocket" );
//    t = lo_address_new("192.168.0.53", "5010"); // for PD
    t = lo_address_new("192.168.0.54", "5010");
//    t = lo_address_new(NULL, "7770");
	if (t == NULL) {printf("OSC address error.\n"); exit(-1);}
//	else {printf("\nOSC send address: %s\n", t);}
/* 
	if (argc <= 1) {
//		printf("Not enough args.\n\tUsage: LEDdataSend DeviceName\n\tEx. %s ttyACM0\n", argv[0]);
//		printf("No args. So using default /dev/ttyACM0\n");

//		First Controller
		memset(devpath, '0', 14);
		strcpy(devpath, "/dev/ttyACM0");
		printf("First Controller: %s\n", devpath);

//		Second Controller
		memset(devpath2, '0', 14);
		strcpy(devpath2, "/dev/ttyACM1");
		printf("Second Controller: %s\n", devpath2);
	} else {
		if (argc <= 2) { // One specified controller only.
			printf("Args are: %s %s \n", argv[0], argv[1]);
			usbdevname = argv[1];
//		devpath = (char *) malloc(14);
			strcpy (devpath, "/tty/");
			strcat(devpath, usbdevname);
			printf("%s %s \n", argv[0], devpath);
		}
		else {
			printf("Args are: %s %s \n", argv[0], argv[1]);
			usbdevname = argv[1];
//		devpath = (char *) malloc(14);
			strcpy (devpath, "/tty/");
			strcat(devpath, usbdevname);

			usbdevname2 = argv[2];
//		devpath2= (char *) malloc(14);
			strcpy (devpath2, "/tty/");
			strcat(devpath2, usbdevname2);
		}
	}
*/

// Handle Ctl-C 
	signal(SIGINT, signal_callback_handler); // so we can Ctrl C out of this cleanly

// Init matrix for LED id assignment
	init_matrix();

//   set up joysticks
	init_joystick1();
	init_joystick2();

//	memset (buf, 0, sizeof(buf));	// zero the buf

	jsize = (&jchar)[1] - jchar;
	jsize2 = (&jchar2)[1] - jchar2;

// Initiate the threads 

	init_threads();

/***************************
		While - Lets's GO!
 ***************************/

 /*  send a message to /a/b/c/d with a mixtrure of float and string arguments */
//	lo_send(t, "/a/b/c/d", "sfsff", "one", 0.12345678f, "three", -0.00000023001f, 1.0);
							   

	while (!STOP) {

/* loop until we have a terminating condition */

	} // end of while

/*************
 * 	FINISHED
 * ***********/

/*  restore the old port settings */
	tcsetattr(port,TCSANOW,&oldtio);
	tcsetattr(port2,TCSANOW,&oldtio2);
	close( port );
	close( port2 );
	close( jfd );
	close( jfd2 );
	printf("Goodbye!\n");
	return 0;

}	// ---------- End of Main -------------------

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  init_joystick1
 *  Description:  
 * =====================================================================================
 */
int
init_joystick1()
{

//	printf("\nOpening SELF JoyS jdevpath);

	memset(jdevpath, '0', 12);
	strcpy(jdevpath, "/dev/hidraw0");
	jfd = open(jdevpath, O_RDWR | O_NOCTTY );
	printf("Device Status %d - %s \n", jfd, jdevpath);
	if (jfd < 0) { perror(jdevpath); printf("Not Found? \n"); exit(-1); } else { printf("Device: %d is open. \n", jfd); }

	return 0;
}		// -----  end of function init_joystick1  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  init_joystick2
 *  Description:
 * =====================================================================================
 */
int
init_joystick2()
{

//	printf("\nOpening TM JoyS jdevpath2);

	memset(jdevpath2, '0', 12);
	strcpy(jdevpath2, "/dev/hidraw1");
	jfd2 = open(jdevpath2, O_RDWR | O_NOCTTY );
	printf("Device Status %d - %s \n", jfd2, jdevpath2);
	if (jfd2 < 0) { perror(jdevpath2); printf("Not Found? \n"); exit(-1); } else { printf("Device: %d is open. \n", jfd2); }

	return 0;

}		// -----  end of function init_joystick2  ----- 

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  init_threads
 *  Description:  
 * =====================================================================================
 */
		void
init_threads ( )
{
	if ((js1 = pthread_create(&js1thread, NULL, js1_thread, (void *) (NULL)))) {
	   fprintf(stderr, "error creating a new Joystick 1 thread.\n");
   	   exit(0);
   	 } else { printf("Joystick 1 Thread created: %d ... ", js1);}

 	pthread_detach(js1thread);

	if (( js2 = pthread_create(&js2thread, NULL, js2_thread, (void * ) (NULL)))) {
	   fprintf(stderr, "error creating a new Joystick 2 thread.\n");
   	   exit(0);
   	 } else { printf("Joystick 2 Thread created: %d ... ", js2);}

 	pthread_detach(js2thread);

	if ((mt1 = pthread_create(&min1thread, NULL, minute_thread1, (void * )(NULL)))) {
		fprintf(stderr, "error creating a new Minute 1 thread.\n");
		exit(0);
	} else { printf("Minute 1 Thread created: %d ... ", mt1);}

	pthread_detach(min1thread);

	if ((mt2 = pthread_create(&min2thread, NULL, minute_thread2, (void * )(NULL)))) {
		fprintf(stderr, "error creating a new Minute 2 thread.\n");
		exit(0);
	} else { printf("Minute 2 Thread created: %d ... ", mt2);}

	pthread_detach(min2thread);

}		// -----  end of function init_threads  ----- 

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  init_matrix
 *  Description:
 * =====================================================================================
 */
		void
init_matrix (void )
{
int i = 0, x = 0, y = 0;

//	memset (Lmatrix, 0, sizeof(Lmatrix));	// zero the matrix

	printf("Matrix max LEDs are: %d \n",maxLeds);
	while (i < maxLeds) {
      for (y=ledsPerLineEnd; y >= 0; y-- ) {
		Lmatrix[x][y] = i++;
//		printf(" %d ",Lmatrix[x][y]);
     }
//	 printf("\n");
     x++;
     for (y=0; y < ledsPerLine; y++ ) {
		Lmatrix[x][y] = i++;
//		printf(" %d ",Lmatrix[x][y]);
     }
//	 printf("\n");
    x++;
   }
}		// -----  end of function init_matrix  ----- 


/*
 * ===  FUNCTION  ======================================================================
 *         Name:  delay
 *  Description:
 * =====================================================================================
*/ 
void delay(int milliseconds) {
long pause;
clock_t now,then;

	pause = milliseconds*(CLOCKS_PER_SEC/1000);
	now = then = clock();
	while( (now-then) < pause ) now = clock();

}	//  -----  end of function delay  ----- 


/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  js1_thread
 *  Description:  Thread for Mad Catz 1
 * =====================================================================================
 */
void *
js1_thread( void * arg) {

//char prevJS = 128;
char prev4 = 128;
char prev5 = 128;
char JSRprev = 'c';
char JSLprev = 'c';
char JSDprev = 'c';
char JSUprev = 'c';
char JSCCWprev = 'c';
char JSCWprev = 'c';
char TLprev = 'c';
char JSTOn = 128;
int x = 16, y = 45;
int jres;
int screen = 0;
int prev_screen = 2;

printf("Joystick 1 Thread Running\n");
    while (!finish) {

// 6 params for the Mad Catz Joystick are from left: first JS buttons and thumb stick;  Last field: Base Lever.
// jchar array	   0    1   2   3	4	5
// passive state = 127 127 127 = read(jfd, jchar, jsize);
//
 		jres = read(jfd, jchar, jsize);
//printf(" Mad Catz 1 jres = %d.  %d %d %d %d %d %d\n", jres, (int)jchar2[0], (int)jchar2[1], (int)jchar2[2], (int)jchar2[3], (int)jchar2[4], (int)jchar2[5]);

		if(jres == 6) {
  			if (jchar[4] != prev4) { // 0 is the default position
				switch (jchar[4]) {
					case 0: 	{ JSTOn = 0; tick1 = 0; break; } //printf("\t\t\t\tTS-2 OFF: %d\n",(int)jchar[4]); break;}
					case 1: 	{ if(screen == 0) { 
									lo_send(t, "/js1/ts1_1", "i", (int)jchar[4]);
									LedsUp1( 8001 );} else { LedsUp2( 8001 );} lo_send(t, "/js1/ts1_1", "i", (int)jchar[4]); break; } //printf("\t\t\tTS2-1: %d\n",(int)jchar[4]); break; }
					case 2: 	{ if(screen == 0) { LedsUp1( 8002 );} else { LedsUp2( 8002 );} lo_send(t, "/js1/ts1_2", "i", (int)jchar[4]); break; } //printf("\t\t\tTS2-2: %d\n",(int)jchar[4]); break; }
					case 3: 	{ if(screen == 0) { LedsUp1( 8003 );} else { LedsUp2( 8003 );} lo_send(t, "/js1/ts1_3", "i", (int)jchar[4]); break; } //printf("\t\t\tTS2-3: %d\n",(int)jchar[4]); break; }
					case 4: 	{ if(screen == 0) { LedsUp1( 8004 );} else { LedsUp2( 8004 );} lo_send(t, "/js1/ts1_4", "i", (int)jchar[4]); break; } //printf("\t\t\tTS2-4: %d\n",(int)jchar[4]); break; }
					case 5: 	{ if(screen == 0) { LedsUp1( 8005 );} else { LedsUp2( 8005 );} lo_send(t, "/js1/ts1_5", "i", (int)jchar[4]); break; } //printf("\t\t\tTS2-5: %d\n",(int)jchar[4]); break; }
					case 6: 	{ if(screen == 0) { LedsUp1( 8006 );} else { LedsUp2( 8006 );} lo_send(t, "/js1/ts1_6", "i", (int)jchar[4]); break; } //printf("\t\t\tTS2-6: %d\n",(int)jchar[4]); break; }
					case 7: 	{ if(screen == 0) { LedsUp1( 8007 );} else { LedsUp2( 8007 );} lo_send(t, "/js1/ts1_7", "i", (int)jchar[4]); break; } //printf("\t\t\tTS2-7: %d\n",(int)jchar[4]); break; }
					case 8: 	{ if(screen == 0) { LedsUp1( 8008 );} else { LedsUp2( 8008 );} lo_send(t, "/js1/ts1_8", "i", (int)jchar[4]); break; } //printf("\t\t\tTS2-8: %d\n",(int)jchar[4]); break; }

					case 16: 	{ tick1 = 0; JSTOn = 129; lo_send(t, "/js1/trig", "i", (int)jchar[4]); break;} //  printf("B1-2 %d\n",jchar[6]); break;}
					case 32: 	{ lo_send(t, "/js1/cb", "i", (int)jchar[4]); //printf("\t\t\tCTB: %d\n",(int)jchar[4]); break;}
								  if( randn (0,100) > 70) {
									LedsUp1( 8010 ); LedsUp2( 8010 );
								  } else {
									if(screen == 0) { LedsUp1( 8010 );} else { LedsUp2( 8010 );} 
								  }
								  break;
								}
					case 64: 	{ if(screen == 0) { LedsUp1( 8012 );} else { LedsUp2( 8012 );} lo_send(t, "/js1/lub", "i", (int)jchar[4]); break; } //printf("\t\t\tRLB: %d\n",(int)jchar[4]); break;}
		 			case 128: 	{ if(screen == 0) { LedsUp1( 8013 );} else { LedsUp2( 8013 );} lo_send(t, "/js1/rub", "i", (int)jchar[4]); break; } //printf("\t\t\tRUB: %d\n",(int)jchar[4]); break;}
				}
				prev4 = jchar[4];
			}

  			if (jchar[5] != prev5) { // 240 is the default position
				switch (jchar[5]) {
					case 240: 	{ lo_send(t, "/js1/lboff", "i", (int)jchar[5]); tick1 = 0; break; } //printf("\t\t\tButtons OFF: %d\n",(int)jchar[5]); break; }
					case 241: 	{ if(screen == 0) { LedsUp1( 8015 );} else { LedsUp2( 8015 );} lo_send(t, "/js1/llb", "i", (int)jchar[5]); break; } //printf("\t\t\tLLB: %d\n",(int)jchar[5]); break; }
					case 242: 	{ if(screen == 0) { LedsUp1( 8014 );} else { LedsUp2( 8014 );} lo_send(t, "/js1/rlb", "i", (int)jchar[5]); break; } //printf("\t\t\tRLB: %d\n",(int)jchar[5]); break; }
					case 244: 	{ if(JSTOn == 0) { 
									lo_send(t, "/js1/lb", "i", (int)jchar[5]);
									if (screen == 0) {
										if (randn(0,100) > 50) { LedsUp1( 8011 ); } else { LedsUp1( 8009 ); }
									} else { 
										if (randn(0,100) > 50) { LedsUp2( 8011 ); } else { LedsUp2( 8009 ); }
									} 
								  } //printf("\t\t\tJSLB: %d\n",(int)jchar[5]); break; }
								  break;
								}
				}
				prev5 = jchar[5];
			}

  			if ((jchar[0] != 0) && (jchar[0] > 127) && (JSRprev != jchar[0]) && (JSTOn == 129)) {
				tick1 = 0; JSRprev = jchar[0]; x = map((int)jchar[0], 255, 128, 31, 16); LedsUp1b(8000, Lmatrix[x][y], buf2); lo_send(t, "/js1/r", "i", (int)jchar[0]);} // printf("\t\t\tJS2-Right: %d\n", (int)jchar[0]);}
 			if ((jchar[0] != 0) && (jchar[0] < 128) && (JSLprev != jchar[0]) && (JSTOn == 129)) {
				tick1 = 0; JSLprev = jchar[0]; x = map((int)jchar[0], 1, 127, 0, 16); LedsUp1b(8000, Lmatrix[x][y], buf2);lo_send(t, "/js1/l", "i", (int)jchar[0]); } //printf("\t\t\t\tJS2-Left: %d\n", x);}

			if ((jchar[1] != 0) && (jchar[1] < 128) && (JSUprev != jchar[1]) && (JSTOn == 129)) {
				tick1 = 0; JSUprev = jchar[1]; y = map((int)jchar[1], 127, 1, 45, 89); LedsUp1b(8000, Lmatrix[x][y], buf2); lo_send(t, "/js1/u", "i", (int)jchar[1]); } // printf("\t\t\t\tJS2-Down: %d\n", y);}
			if ((jchar[1] != 0) && (jchar[1] > 127) && (JSDprev != jchar[1]) && (JSTOn == 129)) {
				tick1 = 0; JSDprev = jchar2[1]; y = map((int)jchar[1], 128, 255, 44, 0); LedsUp1b(8000, Lmatrix[x][y], buf2); lo_send(t, "/js1/d", "i", (int)jchar[1]); } // printf("\t\t\t\tJS2-Up: %d\n", y );}
 
			if ((jchar[2] < 128) && (JSCCWprev != jchar[2])) {
				if (jchar[2] < 100) {
					screen = 0;
					if (screen != prev_screen) {
						tick1 = 0; lo_send(t, "/js1/ccw", "i", (int)screen); prev_screen = screen;}
				}
				JSCCWprev = jchar[2]; // printf("\t\t\t\t\tJS2-CCW: %d\n", (int)jchar[2]);
			}

			if ((jchar[2] > 127) && (JSCWprev != jchar[2])) {
				if (jchar[2] > 156) {
					screen = 1;
					if (screen != prev_screen) {
						tick1 = 0; lo_send(t, "/js1/cw", "i", (int)screen); screen = 1; prev_screen = screen;}
				}
				JSCWprev = jchar[2]; // printf("\t\t\t\t\tJS2-CW: %d\n", (int)jchar[2]);
			}

  			if (jchar[3] != TLprev ) {
//				 if (jchar[3] > 127) { screen = 0; } else { screen = 1; } TLprev = jchar[3]; } 
//				dimSend(screen, jchar[3]); TLprev = jchar[3]; lo_send(t, "/js1tl", "i", (int)jchar[3]); } // printf("Throttle Lever:  %d\n", (int)jchar[3]);}
				TLprev = jchar[3]; lo_send(t, "/js1/tl", "i", (int)jchar[3]); } // printf("Throttle Lever:  %d\n", (int)jchar[3]);}

		} // end of jres if
    }
//printf(" MAD CATZ 1 Exited \n");
	return NULL;

}		// -----  end of function js1_thread  ----- 


/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  js2_thread
 *  Description:  Thread for Mad Catz 2
 * =====================================================================================
 */
void *
js2_thread( void * arg) {

//char prevJS = 128;
char prev4 = 128;
char prev5 = 128;
char JSRprev = 'c';
char JSLprev = 'c';
char JSDprev = 'c';
char JSUprev = 'c';
char JSCCWprev = 'c';
char JSCWprev = 'c';
char TLprev = 'c';
char JSTOn = 128;
int x = 16, y = 45;
int jres;
int screen = 0;
int prev_screen = 0;

printf("Joystick 2 Thread Running\n");
    while (!finish) {

// 6 params for the Mad Catz Joystick are from left: first JS buttons and thumb stick;  Last field: Base Lever.
// jchar array	   0    1   2   3	4	5
// passive state = 127 127 127 = read(jfd2, jchar2, jsize2);
//
 		jres = read(jfd2, jchar2, jsize2);
//printf(" Mad Catz 2 jres = %d.  %d %d %d %d %d %d\n", jres, (int)jchar2[0], (int)jchar2[1], (int)jchar2[2], (int)jchar2[3], (int)jchar2[4], (int)jchar2[5]);

		if(jres == 6) {
  			if (jchar2[4] != prev4) { // 0 is the default position
				switch (jchar2[4]) { // Thumb Stick
					case 0: 	{ JSTOn = 0; tick2= 0; break; } //printf("\t\t\t\tTS-2 OFF: %d\n",(int)jchar2[4]); break;}
					case 1: 	{ if(screen == 0) { 
									lo_send(t, "/js2/ts2_1", "i", (int)jchar2[4]);
									LedsUp1( 8001 );} else { LedsUp2( 8001 );} lo_send(t, "/js2/ts2_1", "i", (int)jchar2[4]); break; } //printf("\t\t\tTS2-1: %d\n",(int)jchar2[4]); break; }
					case 2: 	{ if(screen == 0) { LedsUp1( 8002 );} else { LedsUp2( 8002 );} lo_send(t, "/js2/ts2_2", "i", (int)jchar2[4]); break; } //printf("\t\t\tTS2-2: %d\n",(int)jchar2[4]); break; }
					case 3: 	{ if(screen == 0) { LedsUp1( 8003 );} else { LedsUp2( 8003 );} lo_send(t, "/js2/ts2_3", "i", (int)jchar2[4]); break; } //printf("\t\t\tTS2-3: %d\n",(int)jchar2[4]); break; }
					case 4: 	{ if(screen == 0) { LedsUp1( 8004 );} else { LedsUp2( 8004 );} lo_send(t, "/js2/ts2_4", "i", (int)jchar2[4]); break; } //printf("\t\t\tTS2-4: %d\n",(int)jchar2[4]); break; }
					case 5: 	{ if(screen == 0) { LedsUp1( 8005 );} else { LedsUp2( 8005 );} lo_send(t, "/js2/ts2_5", "i", (int)jchar2[4]); break; } //printf("\t\t\tTS2-5: %d\n",(int)jchar2[4]); break; }
					case 6: 	{ if(screen == 0) { LedsUp1( 8006 );} else { LedsUp2( 8006 );} lo_send(t, "/js2/ts2_6", "i", (int)jchar2[4]); break; } //printf("\t\t\tTS2-6: %d\n",(int)jchar2[4]); break; }
					case 7: 	{ if(screen == 0) { LedsUp1( 8007 );} else { LedsUp2( 8007 );} lo_send(t, "/js2/ts2_7", "i", (int)jchar2[4]); break; } //printf("\t\t\tTS2-7: %d\n",(int)jchar2[4]); break; }
					case 8: 	{ if(screen == 0) { LedsUp1( 8008 );} else { LedsUp2( 8008 );} lo_send(t, "/js2/ts2_8", "i", (int)jchar2[4]); break; } //printf("\t\t\tTS2-8: %d\n",(int)jchar2[4]); break; }

					case 16: 	{ tick2 = 0; JSTOn = 129; lo_send(t, "/js2/trig", "i", (int)jchar[4]) ;break;} //  printf("B1-2 %d\n",jchar[6]); break;}
//					case 32: 	{ if(screen == 0) { LedsUp1( 8010 );} else { LedsUp2( 8010 );} lo_send(t, "/js2/js2cb", "i", (int)jchar2[4]); break; } //printf("\t\t\tCTB: %d\n",(int)jchar2[4]); break;}
					case 32: 	{ lo_send(t, "/js2/cb", "i", (int)jchar[4]); //printf("\t\t\tCTB: %d\n",(int)jchar[4]); break;}
								  if( randn (0,100) > 70) {
									LedsUp1( 8010 ); LedsUp2( 8010 );
								  } else {
									if(screen == 0) { LedsUp1( 8010 );} else { LedsUp2( 8010 );} 
								  }
								  break;
								}
					case 64: 	{ if(screen == 0) { LedsUp1( 8012 );} else { LedsUp2( 8012 );} lo_send(t, "/js2/js2lub", "i", (int)jchar2[4]); break; } //printf("\t\t\tRLB: %d\n",(int)jchar2[4]); break;}
		 			case 128: 	{ if(screen == 0) { LedsUp1( 8013 );} else { LedsUp2( 8013 );} lo_send(t, "/js2/js2rub", "i", (int)jchar2[4]); break; } //printf("\t\t\tRUB: %d\n",(int)jchar2[4]); break;}
				}
				prev4 = jchar2[4];
			}

  			if (jchar2[5] != prev5) { // 240 is the default position
				switch (jchar2[5]) {
					case 240: 	{ lo_send(t, "/js2/lboff", "i", (int)jchar2[5]); tick2 = 0; break; } //printf("\t\t\tButtons OFF: %d\n",(int)jchar2[5]); break; }
					case 241: 	{ if(screen == 0) { LedsUp1( 8015 );} else { LedsUp2( 8015 );} lo_send(t, "/js2/llb", "i", (int)jchar2[5]); break; } //printf("\t\t\tLLB: %d\n",(int)jchar2[5]); break; }
					case 242: 	{ if(screen == 0) { LedsUp1( 8014 );} else { LedsUp2( 8014 );} lo_send(t, "/js2/rlb", "i", (int)jchar2[5]); break; } //printf("\t\t\tRLB: %d\n",(int)jchar2[5]); break; }
//					case 244: 	{ if(screen == 0) { LedsUp1( 8011 );} else { LedsUp2( 8011 );} lo_send(t, "/js2/lb", "i", (int)jchar[5]); break; } //printf("\t\t\tJSLB: %d\n",(int)jchar[5]); break; }
					case 244: 	{ if(JSTOn == 0) { 
								  	lo_send(t, "/js2/lb", "i", (int)jchar2[5]); 
									if (screen == 0) {
										if (randn(0,100) > 50) { LedsUp1( 8011 ); } else { LedsUp1( 8009 ); }
									} else { 
										if (randn(0,100) > 50) { LedsUp2( 8011 ); } else { LedsUp2( 8009 ); }
									} 
								  } //printf("\t\t\tJSLB: %d\n",(int)jchar2[5]); break; }
								  break;
								}
				}
				prev5 = jchar2[5];
			}

  			if ((jchar2[0] != 0) && (jchar2[0] > 127) && (JSRprev != jchar2[0]) && (JSTOn == 129)) {
				tick2 = 0; JSRprev = jchar2[0]; x = map((int)jchar2[0], 255, 128, 31, 16); LedsUp1b(8000, Lmatrix[x][y], buf2); lo_send(t, "/js2/r", "i", (int)jchar2[0]);} // printf("\t\t\tJS2-Right: %d\n", (int)jchar2[0]);}
 			if ((jchar2[0] != 0) && (jchar2[0] < 128) && (JSLprev != jchar2[0]) && (JSTOn == 129)) {
				tick2 = 0; JSLprev = jchar2[0]; x = map((int)jchar2[0], 1, 127, 0, 16); LedsUp1b(8000, Lmatrix[x][y], buf2);lo_send(t, "/js2/l", "i", (int)jchar2[0]); } //printf("\t\t\t\tJS2-Left: %d\n", x);}

			if ((jchar2[1] != 0) && (jchar2[1] < 128) && (JSUprev != jchar2[1]) && (JSTOn == 129)) {
				tick2 = 0; JSUprev = jchar2[1]; y = map((int)jchar2[1], 127, 1, 45, 89); LedsUp1b(8000, Lmatrix[x][y], buf2); lo_send(t, "/js2/u", "i", (int)jchar2[1]); } // printf("\t\t\t\tJS2-Down: %d\n", y);}
			if ((jchar2[1] != 0) && (jchar2[1] > 127) && (JSDprev != jchar2[1]) && (JSTOn == 129)) {
				tick2 = 0; JSDprev = jchar2[1]; y = map((int)jchar2[1], 128, 255, 44, 0); LedsUp1b(8000, Lmatrix[x][y], buf2); lo_send(t, "/js2/d", "i", (int)jchar2[1]); } // printf("\t\t\t\tJS2-Up: %d\n", y );}
 
			if ((jchar2[2] < 128) && (JSCCWprev != jchar2[2])) {
				if (jchar2[2] < 100) {
					screen = 0;
					if (screen != prev_screen) {
						tick2 = 0; lo_send(t, "/js2/ccw", "i", (int)screen); prev_screen = screen;}
				}
				JSCCWprev = jchar2[2]; // printf("\t\t\t\t\tJS2-CCW: %d\n", (int)jchar2[2]);
			}
			if ((jchar2[2] > 127) && (JSCWprev != jchar2[2])) {
				if (jchar2[2] > 156) {
					screen = 1;
					if (screen != prev_screen) {
						tick2 = 0; lo_send(t, "/js2/cw", "i", (int)screen); prev_screen = screen;}
				}
				JSCWprev = jchar2[2]; // printf("\t\t\t\t\tJS2-CW: %d\n", (int)jchar2[2]);
			}
//
//	Audio volume control
//
  			if (jchar2[3] != TLprev ) {
//				 if (jchar2[3] > 127) { screen = 0; } else { screen = 1; } TLprev = jchar2[3]; } 
//				dimSend(screen, jchar2[3]); TLprev = jchar2[3]; lo_send(t, "/js2tl", "i", (int)jchar2[3]); } // printf("Throttle Lever:  %d\n", (int)jchar2[3]);}
				TLprev = jchar2[3]; lo_send(t, "/js2/tl", "i", (int)jchar2[3]); } // printf("Throttle Lever:  %d\n", (int)jchar2[3]);}

		} // end of jres if
    }
//printf(" MAD CATZ 2 Exited \n");
	return NULL;

}		// -----  end of function js2_thread  ----- 


/*
 * ===  FUNCTION  ======================================================================
 *         Name:  LedsUp1b
 *  Description:  This should now write to either ports depending on LED number being over 1439
 *  			  Currently no longer sending colour data, just LED id.
 * =====================================================================================
 */
	void
LedsUp1b (int formId, int ledId, unsigned char *buf)
{
//int	i = 0;
int res;

//	printf("Screen 1 formId %d ledId %d. ", formId, ledId);

	if (ledId < 1440) {
		snprintf((char *)formbuf1, 5, "%d", formId);
		if ((res = write(port, formbuf1, 4)) != 4) {
			printf("\nLedsUp1b formId Failed to write data. ");}
//	else {
//	printf("Screen 1 formId %d  ", formId);
//		printf("Form Data written. %d - ", res);
//	}
		snprintf((char *)ledIdbuf1, 5, "%d", ledId);
		if ((res = write(port, ledIdbuf1, 4)) != 4) {
			printf("\nLedsUp1b ledId Failed to write data.\n");}
/* 
		while (i++ < 3) {
			buf[i] = (unsigned char)rand() % 255;
//			buf[i++] = (unsigned char)rand() % 255;
//			buf[i] = (unsigned char)rand() % 255;
		}

		if ((res = write(port, buf, 3)) != 3) {
			printf("\nLedsUp1b buf Failed to write data.\n");}
*/
	} else { // write to port 2

		snprintf((char *)formbuf1, 5, "%d", formId);
		if ((res = write(port2, formbuf1, 4)) != 4) {
			printf("\nLedsUp1b formId Failed to write data. ");}
//	else {
//	printf("Screen 1 formId %d  ", formId);
//		printf("Form Data written. %d - ", res);
//	}
		snprintf((char *)ledIdbuf1, 5, "%d", ledId - 1440);
		if ((res = write(port2, ledIdbuf1, 4)) != 4) {
		printf("\nLedsUp1b ledId Failed to write data.\n");}
//	else {
//	printf("ledId %d. \n", ledId);
//		printf("LED iD Data written. %d - ", res);
//	}
/* 
	while (i++ < 3) {
		buf[i] = (unsigned char)rand() % 255;
//		buf[i++] = (unsigned char)rand() % 255;
//		buf[i] = (unsigned char)rand() % 255;
	}

	if ((res = write(port2, buf, 3)) != 3) {
		printf("\nLedsUp1b buf Failed to write data.\n");}
//	else {
//		printf("LedsUp1b buf Data written. %d\n", res);
	}
*/
	}
}		// -----  end of LedsUp1b


/*
 * ===  FUNCTION  ======================================================================
 *         Name:  dimBuf
 *  Description:  This writes a dim value. But to which screen? 
 *  			  
 * =====================================================================================
 /
	void
dimSend (int screen, uint8_t dimVal)
{
int res;
int formId  = 7000;

//	printf("Screen 1 formId %d ledId %d. ", formId, ledId);

	if (screen == 0 ) {
		snprintf((char *)formbuf1, 5, "%d", formId);
		if ((res = write(port, formbuf1, 4)) != 4) { printf("\nLedsUp1b formId Failed to write data. ");}

		snprintf((char *)dimBuf, 2, "%d", dimVal);
		if ((res = write(port, dimBuf, 1)) != 1) {
			printf("\nLedsUp1b ledId Failed to write data.\n");}

	} else { // write to screen 2

		snprintf((char *)formbuf1, 5, "%d", formId);
		if ((res = write(port2, formbuf1, 4)) != 4) { printf("\nLedsUp1b formId Failed to write data. ");}

		snprintf((char *)dimBuf, 2, "%d", dimVal);
		if ((res = write(port2, dimBuf, 1)) != 1) { printf("\nLedsUp1b ledId Failed to write data.\n");}
	}
}		// -----  end of dimSend
*/

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  LedsUp1
 *  Description:  
 * =====================================================================================
 */
void
LedsUp1 (int ledId) {
int res;

//	printf("ledId %d led1buf size %d\n", ledId, sizeof(led1buf));
	snprintf((char *)led1buf, 5, "%d", ledId);

	if ((res = write(port, led1buf, 4)) != 4) {
		printf("\nFailed to write data to port.\n"); }
//	} else {
//		printf("screen 1 LEDs ON Data written. %d\n", res);
//	}

}		// -----  end of function LedsUp1  ----- 


/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  LedsUp2
 *  Description:  
 * =====================================================================================
 */
void
LedsUp2 (int ledId2) {
int res;

//	printf("ledId2 %d led2buf size %d\n", ledId2, sizeof(led2buf));
	snprintf((char *)led2buf, 5, "%d", ledId2);

	if ((res = write(port2, led2buf, 4)) != 4) {
		printf("\nFailed to write data to LEDs.\n"); }
//	else {
//		printf("screen 2 LEDs ON Data written. %d %s \n", res, led2buf);
//	}

}		// -----  end of function LedsUp2  ----- 


//=======================================================
//			init_comms ALL comms to Teesnsy 3.1s
//=======================================================
/*
void
init_comms()
{
	init_comms1("/dev/ttyACM0");
	init_comms2("/dev/ttyACM1");

}
*/


/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  init_comms1
 *  Description:  
 * =====================================================================================
 */
int
init_comms1(const char *devpath)
{
	/*
	Open device for reading and writing and not as controlling tty
	because we don't want to get killed if linenoise sends CTRL-C.
	*/
	printf("Opening First Teensy 3.1 Light Controller...\n");

	port = open(devpath, O_RDWR | O_NOCTTY );
	printf("Device Status %d ... ", port);
	if (port < 0) {perror(devpath); exit(-1); } else {printf("Teensy 3.1 Device 1: %d is open.\n", port);}

	tcgetattr(port,&oldtio); /* save current serial port settings */
	bzero(&newtio, sizeof(newtio)); /* clear struct for new port settings */

 	/*
	BAUDRATE: Set bps rate. You could also use cfsetispeed and cfseted.
	CRTSCTS : output hardware flow control (only used if the cable has
	all necessary lines. See sect. 7 of Serial-HOWTO)
	CS8     : 8n1 (8bit,no parity,1 stopbit)
	CLOCAL  : local connection, no modem contol
	CREAD   : enable receiving characters
	*/
	newtio.c_cflag = BAUDRATE | CRTSCTS | CS8 | CLOCAL | CREAD;

	/*
	IGNPAR  : ignore bytes with parity errors
	ICRNL   : map CR to NL (otherwise a CR input on the other computer
                    will not terminate input)
	otherwise make device raw (no other input processing)
    */
	newtio.c_iflag = IGNPAR | ICRNL;
	/*
	Raw output.
	newtio.c_oflag = 0;
	*/

	/*
	ICANON  : enable canonical input
	disable all echo functionality, and don't send signals to calling program
	*/
	newtio.c_lflag = ICANON;

	/*
	initialize all control characters
	default values can be found in /usr/include/termios.h, and are given
	in the comments, but we don't need them here
	*/

	newtio.c_cc[VINTR]    = 0;     /*  Ctrl-c */
	newtio.c_cc[VQUIT]    = 0;     /*  Ctrl-\ */
	newtio.c_cc[VERASE]   = 0;     /*  del */
	newtio.c_cc[VKILL]    = 0;     /*  @ */
	newtio.c_cc[VEOF]     = 4;     /*  Ctrl-d */
	newtio.c_cc[VTIME]    = 0;     /*  inter-character timer unused */
	newtio.c_cc[VMIN]     = 0;     /*  non blocking */
	newtio.c_cc[VSWTC]    = 0;     /*  '\0' */
	newtio.c_cc[VSTART]   = 0;     /*  Ctrl-q */
	newtio.c_cc[VSTOP]    = 0;     /*  Ctrl-s */
	newtio.c_cc[VSUSP]    = 0;     /*  Ctrl-z */
	newtio.c_cc[VEOL]     = 0;     /*  '\0' */
	newtio.c_cc[VREPRINT] = 0;     /*  Ctrl-r */
	newtio.c_cc[VDISCARD] = 0;     /*  Ctrl-u */
	newtio.c_cc[VWERASE]  = 0;     /*  Ctrl-w */
	newtio.c_cc[VLNEXT]   = 0;     /*  Ctrl-v */
	newtio.c_cc[VEOL2]    = 0;     /*  '\0' */
																		
	/*
	now clean the modem line and activate the settings for the port
	*/
	tcflush(port, TCIFLUSH);
	tcsetattr(port,TCSANOW,&newtio);
	return 0;

}		// -----  end of function init_comms1  ----- 


/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  init_comms2
 *  Description:  
 * =====================================================================================
 */
int
init_comms2 (const char * devpath2)
{
	/*
	Open device for reading and writing and not as controlling tty
	because we don't want to get killed if linenoise sends CTRL-C.
	*/
	printf("Opening Second Teensy 3.1 Light Controller...%s\n", devpath2);

	port2 = open(devpath2, O_RDWR | O_NOCTTY );
	printf("Device Status %d ... ", port2);
	if (port2 < 0) {perror(devpath2); exit(-1); } else {printf("Teensy 3.1 Device 2: %d is open.\n", port2);}

	tcgetattr(port2,&oldtio2); /* save current serial port settings */
	bzero(&newtio2, sizeof(newtio2)); /* clear struct for new port settings */

 	/*
	BAUDRATE: Set bps rate. You could also use cfsetispeed and cfsetospeed.
	CRTSCTS : output hardware flow control (only used if the cable has
	all necessary lines. See sect. 7 of Serial-HOWTO)
	CS8     : 8n1 (8bit,no parity,1 stopbit)
	CLOCAL  : local connection, no modem contol
	CREAD   : enable receiving characters
	*/
	newtio2.c_cflag = BAUDRATE | CRTSCTS | CS8 | CLOCAL | CREAD;

	/*
	IGNPAR  : ignore bytes with parity errors
	ICRNL   : map CR to NL (otherwise a CR input on the other computer
                    will not terminate input)
evice raw (no other input processing)
    */
	newtio2.c_iflag = IGNPAR | ICRNL;
	/*
	Raw output.
	newtio.c_oflag = 0;
	*/

	/*
	ICANON  : enable canonical input
	disable all echo functionality, and don't send signals to calling program
	*/
	newtio2.c_lflag = ICANON;

	/*
	initialize all control characters
	default values can be found in /usr/include/termios.h, and are given
	in the comments, but we don't need them here
	*/

	newtio2.c_cc[VINTR]    = 0;     /* Ctrl-c */
	newtio2.c_cc[VQUIT]    = 0;     /* Ctrl-\ */
	newtio2.c_cc[VERASE]   = 0;     /* del */
	newtio2.c_cc[VKILL]    = 0;     /* @ */
	newtio2.c_cc[VEOF]     = 4;     /* Ctrl-d */
	newtio2.c_cc[VTIME]    = 0;     /* inter-character timer unused */
	newtio2.c_cc[VMIN]     = 0;     /* non blocking */
	newtio2.c_cc[VSWTC]    = 0;     /* '\0' */
	newtio2.c_cc[VSTART]   = 0;     /* Ctrl-q */
	newtio2.c_cc[VSTOP]    = 0;     /* Ctrl-s */
	newtio.c_cc[VSUSP]    = 0;     /* Ctrl-z */
	newtio2.c_cc[VEOL]     = 0;     /* '\0' */
	newtio2.c_cc[VREPRINT] = 0;     /* Ctrl-r */
	newtio2.c_cc[VDISCARD] = 0;     /* Ctrl-u */
	newtio2.c_cc[VWERASE]  = 0;     /* Ctrl-w */
	newtio2.c_cc[VLNEXT]   = 0;     /* Ctrl-v */
	newtio2.c_cc[VEOL2]    = 0;     /* '\0' */

	/*
	now clean the modem line and activate the settings for the port
	*/
	tcflush(port2, TCIFLUSH);
	tcsetattr(port2,TCSANOW, &newtio2);
	return 0;

}		// -----  end of function init_comms2  ----- 

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  msleep
 *  Description:  
 * =====================================================================================
 */
void msleep(int ms) {
	struct timespec time;
	time.tv_sec = ms /1000;
	time.tv_nsec = (ms % 1000) * (1000 * 1000);
	nanosleep(&time, NULL);

}		// -----  end of function msleep  ----- 


/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  minute_thread1
 *  Description:  
 * =====================================================================================
 */
void * 
minute_thread1(void * arg)
{
	printf("Minute Thread 1 running...\n");

	while (!STOP) {
		msleep(60000);
		tick1++;
		tick2++;
		tick3 = 0;
		if ((tick1 >= IDLETIME) && (tick2 >= IDLETIME) && (autorun == FALSE)) {autorun = TRUE; } //printf("Thread 1 Auto run TRUE: T1 %d T2 %d T3 %d\n", tick1, tick2, tick3);}
	}
	return NULL;

}		// -----  end of function minute_thread1  ----- 


/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  minute_thread2
 *  Description:  
 * =====================================================================================
 */
void * 
minute_thread2(void * arg)
{
	printf("Minute Thread 2 running...\n");

	while (!STOP) {
		if ((tick1 >= IDLETIME) && (tick2 >= IDLETIME) && (autorun == TRUE )) { tick3++; msleep(15000); } //printf("Thread 2 Auto run TRUE: T1 %d T2 %d T3 %d\n", tick1, tick2, tick3);}
		else { tick3 = 0; autorun = FALSE; msleep(15000);} //  printf("Thread 2 Auto run FALSE: T1 %d T2 %d T3 %d\n", tick1, tick2, tick3);}
		if ((tick1 >= IDLETIME) && (tick2 >= IDLETIME) && (tick3 >= IDLETIME) && (autorun == TRUE)) { autoRun(); tick1 = 0; tick2 = 0; tick3 = 0; autorun = FALSE;}
	}
	return NULL;

}		// -----  end of function minute_thread2  ----- 


/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  autoRun
 *  Description:  
 * =====================================================================================
 */
		void
autoRun (void)
{
	printf("\nGoing into Auto mode...\n\n");  

//    delay(100);

	LedsUp1( 8010);
	LedsUp2( 8010);

	while ((tick1 >= IDLETIME) && (tick2 >= IDLETIME) && (autorun == TRUE)) {
		switch (randn(0,20)) {
			case 0: 	{ LedsUp1( 8001 ); break; }
			case 1: 	{ LedsUp1( 8002 ); break; }
			case 2: 	{ LedsUp1( 8003 ); break; }
			case 3: 	{ LedsUp1( 8004 ); break; }
			case 4: 	{ LedsUp1( 8005 ); break; }
			case 5: 	{ LedsUp1( 8006 ); break; }
			case 6: 	{ LedsUp1( 8007 ); break; }
			case 7: 	{ LedsUp1( 8008 ); break; }
			case 8: 	{ LedsUp1( 8009 ); break; }
			case 9: 	{ LedsUp1( 8010 ); break; } // clear screen
			case 10: 	{ LedsUp1( 8011 ); break; }
			case 11: 	{ LedsUp1( 8010 ); break; }
			case 12: 	{ LedsUp1( 8012 ); break; }
		 	case 13: 	{ LedsUp1( 8013 ); break; }
		 	case 14: 	{ LedsUp1( 8014 ); break; }
		 	case 15: 	{ LedsUp1( 8015 ); break; } // Mondrian like...
			default: break;
		}
		if (randn(0,101) > 50) {delay(randn(50,1000));};
  		switch (randn(0,15)) {
			case 0: 	{ LedsUp2( 8001 ); break; }
			case 1: 	{ LedsUp2( 8002 ); break; }
			case 2: 	{ LedsUp2( 8003 ); break; }
			case 3: 	{ LedsUp2( 8004 ); break; }
			case 4: 	{ LedsUp2( 8005 ); break; }
			case 5: 	{ LedsUp2( 8006 ); break; }
			case 6: 	{ LedsUp2( 8007 ); break; }
			case 7: 	{ LedsUp2( 8008 ); break; }
			case 8: 	{ LedsUp2( 8009 ); break; }
			case 9: 	{ LedsUp2( 8010 ); break; } // clear screen
			case 10: 	{ LedsUp2( 8011 ); break; }
			case 11: 	{ LedsUp2( 8010 ); break; }
		 	case 12: 	{ LedsUp2( 8012 ); break; }
		 	case 13: 	{ LedsUp2( 8013 ); break; }
		 	case 14: 	{ LedsUp2( 8014 ); break; }
		 	case 15: 	{ LedsUp2( 8015 ); break; } // Mondrian like...
//			default: break;
		}
		delay(randn(50,1000));
	} // end atuo while loop

	LedsUp1( 8010);
	LedsUp2( 8010);
	tick1 = 0;
	tick2 = 0;
	tick3 = 0;
	autorun = FALSE;
	printf("\nLeaving Auto mode...\n\n");  
//		return 0;

}		// -----  end of function autoRun  ----- 


/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  udev_assignment
 *  Description:  
 * =====================================================================================
 */
	int
udev_assignment ( void )
{
struct udev *udev;
struct udev_enumerate *enumerate;
struct udev_list_entry *devices, *dev_list_entry;
struct udev_device *dev;
int dev_state;
int dev_cnt = 0;
int Teensys_matched = 2;

 while (dev_cnt < DEVICE_CNT) { // what to loop through potential devices and find there serial number which should be unique for the Teensy 3.1

	/* Create the udev object */
	udev = udev_new();

	if (!udev) {
		printf("Can't create udev: %s\n", udevnames[dev_cnt]);
		exit(1);
	}

	/* Create a list of the devices in the 'hidraw' subsystem. */
	enumerate = udev_enumerate_new(udev);
//	if((dev_state = udev_enumerate_add_match_parent(enumerate, dev)) >= 0) {printf("found device struct. %d\n", dev_state);}
	if((dev_state = udev_enumerate_add_match_sysname(enumerate, udevnames[dev_cnt])) >= 0) {printf("Found device struct. %d\n", dev_state);}
//	if((dev_state = udev_enumerate_add_match_subsystem(enumerate, udevnames)) >= 0) {printf("found device struct. %d\n", dev_state);}
	if((dev_state = udev_enumerate_scan_devices(enumerate)) >= 0) {printf("Scanned device. %d\n", dev_state);}
//	udev_enumerate_scan_devices(enumerate);
	devices = udev_enumerate_get_list_entry(enumerate);

	/* For each item enumerated, print out its information.
	   udev_list_entry_foreach is a macro which expands to
	   a loop. The loop will be executed for each member in
	   devices, setting dev_list_entry to a list entry
	   which contains the device's path in /sys. */
	udev_list_entry_foreach(dev_list_entry, devices) {
		const char *path;

		/* Get the filename of the /sys entry for the device
		   and create a udev_device object (dev) representing it */
		path = udev_list_entry_get_name(dev_list_entry);
		dev = udev_device_new_from_syspath(udev, path);

		/* usb_device_get_devnode() returns the path to the device node
		   itself in /dev. */
		printf("\tDevice Node Path: %s\n", dev_node = udev_device_get_devnode(dev));

		/* The device pointed to by dev contains information about
		   the hidraw device. In order to get information about the
		   USB device, get the parent device with the
		   subsystem/devtype pair of "usb"/"usb_device". This will
		   be several levels up the tree, but the function will find
		   it.*/
		dev = udev_device_get_parent_with_subsystem_devtype(
		       dev,
		       "usb",
		       "usb_device");
		if (!dev) {
			printf("Unable to find parent usb device.\n");
			exit(1);
		}

		/* From here, we can call get_sysattr_value() for each file
		   in the device's /sys entry. The strings passed into these
		   functions (idProduct, idVendor, serial, etc.) correspond
		   directly to the files in the directory which represents
		   the USB device. Note that USB strings are Unicode, UCS2
		   encoded, but the strings returned from
		   udev_device_get_sysattr_value() are UTF-8 encoded. */

		printf("\tVID/PID: %s %s\n",
		        udev_device_get_sysattr_value(dev,"idVendor"),
		        udev_device_get_sysattr_value(dev, "idProduct"));
		printf("\tManufacturer:  %s\n\tProduct: %s\n",
		        udev_device_get_sysattr_value(dev,"manufacturer"),
		        udev_device_get_sysattr_value(dev,"product"));
//		printf("  serial: %s\n", serial_name = udev_device_get_sysattr_value(dev, "serial"));
		serial_num = udev_device_get_sysattr_value(dev, "serial");
		if(strcmp(serial_num, serial_nums[0]) == 0) {
			printf("serial number %s matched expected number %s.\n\n", serial_num, serial_nums[0]);
			printf("Assigning to port to %s.\n\n", dev_node);
			init_comms1(dev_node);
			Teensys_matched--;
		}
		if(strcmp(serial_num, serial_nums[1]) == 0) {
			printf("serial number %s matched expected number %s.\n\n", serial_num, serial_nums[1]);
			printf("Assigning to port2 to %s.\n\n", dev_node);
			init_comms2(dev_node);
			Teensys_matched--;
		}
		udev_device_unref(dev);
	}
	/* Free the enumerator object */
	udev_enumerate_unref(enumerate);

	udev_unref(udev);
	dev_cnt++; // Increment to the next devie

	} // End of Device while loop

	return Teensys_matched;
}
		/* -----  end of function udev_assignment  ----- */


/*
 * ===  FUNCTION  ======================================================================
 *         Name:  map
 *  Description:
 * =====================================================================================
 */
inline int map(int x, int in_min, int in_max, int out_min, int out_max)
{
		return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;

}	//  -----  end of function map  ----- 


/*
 * ===  FUNCTION  ======================================================================
 *         Name:  randn
 *  Description:
 * =====================================================================================
 */
int randn(int min_num, int max_num) {
	int result=0,low_num=0,hi_num=0;

	if(min_num<max_num) {
		low_num=min_num;
		hi_num=max_num+1; // this is done to include max_num in output.
	}else{
		low_num=max_num+1;// this is done to include max_num in output.
		hi_num=min_num;
	}
   result = (random()%(hi_num-low_num))+low_num;
   return result;

}	//  -----  end of function randn  ----- 


/* 
 * ===  FUNCTION  ======================================================================
 *         Name: signal_callback_handler
 *  Description:  
 * =====================================================================================
 */
void signal_callback_handler(int signum)  {

	printf("Caught signal %d. Reseting and Exiting...\n", signum);

	LedsUp1(8010);
	LedsUp2(8010);

	tick1 = 0;
	tick2 = 0;
	autorun = FALSE;
	finish = TRUE;
	STOP = TRUE;

}		// -----  end of function signal_callback_handler  ----- 

/********************************************************************
 * 
 *				OLD CODE below
 *
 *
 ********************************************************************/
/*
 * ===  FUNCTION  ======================================================================
 *         Name:  LedsUp2b
 *  Description:
 * =====================================================================================
 */
/*  	void
LedsUp2b (int formId, int ledId, unsigned char *buf)
{
int	i = 0;
int res;

//	printf("Screen 2 formId %d ledId %d. ", formId, ledId );
	snprintf((char *)formbuf2, 5, "%d", formId);
	if ((res = write(port2, formbuf2, 4)) != 4) {
		printf("\nLedsUp2b formId Failed to write data.\n");}
	else {
	printf("Screen 2 formId %d,  ", formId );
//		printf("LedsUp2b FormId Data written. %d - ", res);
	}
	snprintf((char *)ledIdbuf2, 6, "%d", ledId);
	if ((res = write(port2, ledIdbuf2, 5)) != 5) {
		printf("\nLedsUp1b ledId Failed to write data.\n");}
	else {
	printf(" ledId %d.\n ", ledId );
//		printf("LedsUp2b Id Data written %d - ", res);
	}

	while (i < 3) {
		buf[i++] = (unsigned char)rand() % 255;
		buf[i++] = (unsigned char)rand() % 255;
		buf[i] = (unsigned char)rand() % 255;
	}

	if ((res = write(port2, buf, 3)) != 3) {
		printf("\nLedsUp2b buf Failed to write data.\n");}
//	else {
//		printf("LedsUp2b buf Data written. %d\n", res);
//	}

}		// -----  end of function LedsUp  ----- *
*/

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  urandom
 *  Description:
 * =====================================================================================
 *
int urandom(){
   FILE *rand = fopen("/dev/urandom","r");
   unsigned char c1 = getc(rand);
   unsigned char c2 = getc(rand);
   fclose(rand);
   return (int)c1*c2;
} */

/*
//=======================================================
//			js2_thread - ThrustMaster
//=======================================================
void *
js2_thread( void * arg) {

char prev2 = 128;
char JSRprev = 'c';
char JSLprev = 'c';
char JSDprev = 'c';
char JSUprev = 'c';
char JSTOn = 128;
int x = 16, y = 45;
int jres;

printf("Joystick 2 Thread Running\n");
    while (!finish) {

// 4 params for the Thrustmaster Joystick are from left: first JS buttons and thumb stick;  Last field: Base Lever.
// jchar array	   0    1   2   3
// passive state = 127 127 127 = read(jfd2, jchar2, jsize2);
// `
 		jres = read(jfd2, jchar2, jsize2);
		if(jres == 4) {
//printf(" Thrustmaster jres2 = %d.  %d %d %d %d \n", jres2, jchar2[0], jchar2[1], jchar2[2], jchar2[3]);
  			if (jchar2[0] != prev2) { // 8 is the default position
				tick2 = 0;
				switch (jchar2[0]) {
					case 0: 	{ LedsUp2( 8001); prev2 = jchar2[0]; break;} //printf("\t\t\tTS2-0: %d\n",jchar2[0]); prev2 = jchar2[0]; break; }
					case 16: 	{ LedsUp2( 8002); prev2 = jchar2[0]; break;} //printf("\t\t\tTS2-1: %d\n",jchar2[0]); prev2 = jchar2[0]; break; }
					case 32: 	{ LedsUp2( 8003); prev2 = jchar2[0]; break;} //printf("\t\t\tTS2-2: %d\n",jchar2[0]); prev2 = jchar2[0]; break; }
					case 48: 	{ LedsUp2( 8004); prev2 = jchar2[0]; break;} //printf("\t\t\tTS2-3: %d\n",jchar2[0]); prev2 = jchar2[0]; break; }
					case 64: 	{ LedsUp2( 8005); prev2 = jchar2[0]; break;} //printf("\t\t\tTS2-4: %d\n",jchar2[0]); prev2 = jchar2[0]; break; }
					case 80: 	{ LedsUp2( 8006); prev2 = jchar2[0]; break;} //printf("\t\t\tTS2-5: %d\n",jchar2[0]); prev2 = jchar2[0]; break; }
					case 96: 	{ LedsUp2( 8007); prev2 = jchar2[0]; break;} //printf("\t\t\tTS2-6: %d\n",jchar2[0]); prev2 = jchar2[0]; break; }
					case 112: 	{ LedsUp2( 8008); prev2 = jchar2[0]; break;} //printf("\t\t\tTS2-7: %d\n",jchar2[0]); prev2 = jchar2[0]; break; }
					case 128: 	{ prev2 = jchar2[0]; JSTOn = 0; break; } //printf("\t\t\t\tOFF: %d\n",jchar2[0]); break;}
					case 129: 	{ prev2 = jchar2[0]; JSTOn = 129; break; } //printf("\t\t\tJST: %d\n",jchar2[0]); break;}
					case 130: 	{ LedsUp2( 8011); prev2 = jchar2[0]; break; } //printf("\t\t\tJSBC2: %d\n",jchar2[0]); break;}
					case 132: 	{ if( randn(0,101) > 50 ) {LedsUp2(8010);} else { LedsUp1(8010);} prev2 = jchar2[0]; break; } //printf("\t\t\tJSBR2-2: %d\n",jchar2[0]); break;}
		 			case 136: 	{ LedsUp2( 8012); prev2 = jchar2[0]; break; } //printf("\t\t\tJSBR2: %d\n",jchar2[0]); break;}
				}
			}

  			if ((jchar2[1] != 0) && (jchar2[1] > 127) && (JSRprev != jchar2[1]) && (JSTOn == 129)) {
				tick2 = 0; JSRprev = jchar2[1]; x = map((int)jchar2[1], 255, 128, 16, 0); LedsUp1b(8000, Lmatrix[x][y], buf2);} //  printf("\t\t\tJS2-Right: %d\n", x);}
 			if ((jchar2[1] != 0) && (jchar2[1] < 128) && (JSLprev != jchar2[1]) && (JSTOn == 129)) {
				tick2 = 0; JSLprev = jchar2[1]; x = map((int)jchar2[1], 0, 127, 17, 31); LedsUp1b(8000, Lmatrix[x][y], buf2); } //printf("\t\t\t\tJS2-Left: %d\n", x);}
			if ((jchar2[2] != 0) && (jchar2[2] < 128) && (JSDprev != jchar2[2]) && (JSTOn == 129)) {
				tick2 = 0; JSDprev = jchar2[2]; y= map((int)jchar2[2], 0, 127, 44, 0); LedsUp1b(8000, Lmatrix[x][y], buf2);} // printf("\t\t\t\tJS2-Down: %d\n", y);}
			if ((jchar2[2] != 0) && (jchar2[2] > 127) && (JSUprev != jchar2[2]) && (JSTOn == 129)) {
				tick2 = 0; JSUprev = jchar2[2]; y = map((int)jchar2[2], 255, 128, 45, 89); LedsUp1b(8000, Lmatrix[x][y], buf2);} // printf("\t\t\t\tJS2-Up: %d\n", y );}

		} // end of jres2 if
    }
//printf(" THRUSTMASTER Exited \n");
	return NULL;
}
*/

/*
 *
 * Original Author: Alan Ott
 * DLM: 12/26/15 16:55:48
 * Compile: gcc -Wall -g -o udev_simple udev_simple.c -ludev
 *
 * Comments: doesn't work for ttyACM but OK with hidraw. Don't know why.
 *
 *   serial: 828800
 *   found device struct. 0
 *   scanned device. 0
 *   Device Node Path1: /dev/ttyACM1
 *   VID/PID: 16c0 0483
 *   Teensyduino
 *   USB Serial
 *   serial: 1369580
*

#include <libudev.h>
#include <stdio.h>
#include <stdlib.h>
#include <locale.h>
#include <unistd.h>
#include <string.h>

#define DEVICE_CNT 2

char *udevname[]  = {"ttyACM0", "ttyACM1"};
//const char *serial_nums[]  = {"828800", "1369580"};
const char *serial_nums[]  = {"462150", "532430"};
const char *serial_num;
const char *dev_node;

*
 * ===  FUNCTION  ======================================================================
 *         Name:  main
 *  Description:
 * =====================================================================================
 *
		int
main ( int argc, char *argv[] )
{
	struct udev *udev;
	struct udev_enumerate *enumerate;
	struct udev_list_entry *devices, *dev_list_entry;
	struct udev_device *dev;
	int dev_state;
	int dev_cnt = 0;
*/
/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  js1_thread
 *  Description:  
 * =====================================================================================
 *
void *
js1_thread( void * arg) {

//char BRprev = 'c';
//char JSleftPrev = 'c';
char JSHprev = 127;
char JSVprev = 127;
//char JSdownPrev = 127;
//char ROTprev = 'c';
char TSprev = 127;
char JSBprev = 127;
char JSTOn = 127;
char JSCWprev = 'c';
char JSCCWprev = 'c';
char TLprev = 127;
int x = 16, y = 45;
int jres;
int screen = 0;

printf("Joystick 1 Thread Running\n");
    while (!finish) {
// 8 params for the SELF Joystick are from left: first 3 = js x,y movement and js rotation; nothing; bottom front heel; Thumb stick (0-8) 8 being middle; final two, buttons (js and base)
// jchar array	   0    1   2   3   4  5 6 7
// passive state = 127 127 127 127 255 8 0 0

		jres = read(jfd, jchar, jsize);
		if(jres == 8) {
//printf("SELF jres = %d %d %d %d %d %d %d %d %d\n", jres, jchar[0], jchar[1], jchar[2], jchar[3], jchar[4], jchar[5], jchar[6], jchar[7]);
*
			if ((jchar[0] != JSHprev) && (JSTOn == 1) && (jchar[0] < JSHprev)) { tick = 0; JSHprev = jchar[0]; x = map((int)jchar[0], 127, 0, 16, 0); LedsUp1b(8000, Lmatrix[x][y], buf); 
				printf("\tx %d, JS1-Left %d LM %d\n ",x, jchar[0], Lmatrix[x][y]); }

			if ((jchar[0] != JSHprev) && (JSTOn == 1) && (jchar[0] > JSHprev)) { tick = 0; JSHprev = jchar[0]; x = map((int)jchar[0], 128, 255, 17, 31 ); LedsUp1b(8000, Lmatrix[x][y], buf); 
				printf("\t\tx %d, JS1-Right %d LM %d\n ",x, jchar[0], Lmatrix[x][y]); } 

			if ((jchar[1] != JSVprev) && (JSTOn == 1) && (jchar[1] > JSVprev)) { tick = 0; JSVprev = jchar[1]; y = map((int)jchar[1], 128, 255, 44, 0); LedsUp1b(8000, Lmatrix[x][y], buf); 
				printf("\t\t\ty %d, LEDs Down %d LM %d\n ", y ,jchar[1], Lmatrix[x][y]); }

			if ((jchar[1] != JSVprev) && (JSTOn == 1) && (jchar[1] < JSVprev)) { tick = 0; JSVprev = jchar[1]; y = map((int)jchar[1], 127, 0, 45, 89); LedsUp1b(8000, Lmatrix[x][y], buf); 
				printf("\t\t\t\ty %d, LEDs Up %d LM %d\n ", y ,jchar[1], Lmatrix[x][y]);}
*
  			if (jchar[5] != TSprev) { // 8 is the default position but TS can abe rotated around without returning to default position
				tick1 = 0;
				switch (jchar[5]) {
					case 0: { if(screen == 0) { LedsUp2( 8001 );} else { LedsUp1( 8001 );} break; } //printf("TS1-0 %d\n",jchar[5]); break;}
					case 1: { if(screen == 0) { LedsUp2( 8002 );} else { LedsUp1( 8002 );} break;} //printf("TS1-1 %d\n",jchar[5]); break;}
					case 2: { if(screen == 0) { LedsUp2( 8003 );} else { LedsUp1( 8003 );} break;} //printf("TS1-2 %d\n",jchar[5]); break;}
					case 3: { if(screen == 0) { LedsUp2( 8004 );} else { LedsUp1( 8004 );} break;} //printf("TS1-3 %d\n",jchar[5]); break;}
					case 4: { if(screen == 0) { LedsUp2( 8005 );} else { LedsUp1( 8005 );} break;} //printf("TS1-4 %d\n",jchar[5]); break;}
					case 5: { if(screen == 0) { LedsUp2( 8006 );} else { LedsUp1( 8006 );} break;} //printf("TS1-5 %d\n",jchar[5]); break;}
					case 6: { if(screen == 0) { LedsUp2( 8007 );} else { LedsUp1( 8007 );} break;} //printf("TS1-6 %d\n",jchar[5]); break;}
					case 7: { if(screen == 0) { LedsUp2( 8008 );} else { LedsUp1( 8008 );} break;} //printf("TS1-7 %d\n",jchar[5]); break;}
					case 8: { break;} //printf("TS1-OFF %d\n",jchar[5]); break;}
				}
				TSprev = jchar[5];
			}
//			} else if ((jchar[5] == 8) && (jchar[5] != TSprev)) {printf("\tTS1%d goes off %d\n", TWprev, jchar[5]); TSprev = jchar[5];}

//  			if ((jchar[6] != 0) && (jchar[6] != JSTprev)) {
  			if (jchar[6] != JSBprev) {
				tick1 = 0;
				switch (jchar[6]) {
					case 0: { JSTOn = 0; break;} //printf("B1-OFF %d\n",jchar[6]); JSTOn = 0; break;}
					case 1: { if(screen == 0) { LedsUp2( 8010 );} else { LedsUp1( 8010 );} 
//							printf("Trig1 %d\n",jchar[6]);
							break;}
					case 2: { JSTOn = jchar[6]; break;} //  printf("B1-2 %d\n",jchar[6]); break;}
					case 4: { if(screen == 0) { LedsUp2( 8011 );} else { LedsUp1( 8011 );} break;} //printf("B1-3 %d\n",jchar[6]); break;}
					case 8: { if(screen == 0) { LedsUp2( 8012 );} else { LedsUp1( 8012 );} break;} //printf("B1-4 %d\n",jchar[6]); break;}
					case 16: { if(screen == 0) { LedsUp2( 8013 );} else { LedsUp1( 8013 );} break;} //printf("B1-5 %d\n",jchar[6]); break;}
					case 32: { if(screen == 0) { LedsUp2( 8014 );} else { LedsUp1( 8014 );} break;} //printf("B1-6 %d\n",jchar[6]); break;}
//					case 64: {printf("B1-7 %d\n",jchar[6]); break;}
//					case 128: {printf("B1-8 %d\n",jchar[6]); break;}
				}
				JSBprev = jchar[6];
			}

			if ((jchar[0] != JSHprev) && (JSTOn == 2) && (jchar[0] < JSHprev)) { tick1 = 0; JSHprev = jchar[0]; x = map((int)jchar[0], 127, 0, 16, 0); LedsUp1b(8000, Lmatrix[x][y], buf); }
//				printf("\tx %d, JS1-Left %d LM %d\n ",x, jchar[0], Lmatrix[x][y]); }

			if ((jchar[0] != JSHprev) && (JSTOn == 2) && (jchar[0] > JSHprev)) { tick1 = 0; JSHprev = jchar[0]; x = map((int)jchar[0], 128, 255, 17, 31 ); LedsUp1b(8000, Lmatrix[x][y], buf); }
//				printf("\t\tx %d, JS1-Right %d LM %d\n ",x, jchar[0], Lmatrix[x][y]); } 

			if ((jchar[1] != JSVprev) && (JSTOn == 2) && (jchar[1] > JSVprev)) { tick1 = 0; JSVprev = jchar[1]; y = map((int)jchar[1], 128, 255, 44, 0); LedsUp1b(8000, Lmatrix[x][y], buf); }
//				printf("\t\t\ty %d, LEDs Down %d LM %d\n ", y ,jchar[1], Lmatrix[x][y]); }

			if ((jchar[1] != JSVprev) && (JSTOn == 2) && (jchar[1] < JSVprev)) { tick1 = 0; JSVprev = jchar[1]; y = map((int)jchar[1], 127, 0, 45, 89); LedsUp1b(8000, Lmatrix[x][y], buf); }
//				printf("\t\t\t\ty %d, LEDs Up %d LM %d\n ", y ,jchar[1], Lmatrix[x][y]);}

			if ((jchar[2] < 128) && (JSCCWprev != jchar[2])) {
				if (jchar[2] < 100) {
					screen = 1; tick1 = 0; }
				tick1 = 0; JSCCWprev = jchar[2]; // printf("\t\t\t\t\tJS1-CCW: %d\n", (int)jchar[2]);
			}
			if ((jchar[2] > 127) && (JSCWprev != jchar[2])) {
				if (jchar[2] > 156) {
					screen = 0; tick1 = 0;}
				tick1 = 0; JSCWprev = jchar[2];  // printf("\t\t\t\t\tJS1-CW: %d\n", (int)jchar[2]);
			}
//			} else if ((jchar[6] == 0) && (jchar[6] != JSBprev)) { printf("\t%d JS1 Button goes off %d\n",JSBprev, jchar[6]); JSBprev = jchar[6];}
//
//  			if (jchar[4] != BLprev ) { if (jchar[4] > 127) { screen = 0; } else { screen = 1; } BLprev = jchar[4];}
  			if (jchar[4] != TLprev ) { dimSend(screen, jchar[4]); TLprev = jchar[4]; } // printf("Throttle Lever:  %d\n", (int)jchar[4]);}

*
  			if ((jchar[7] != 0)  && (jchar[7] != BBprev)) {
				switch (jchar[7]) {
					case 1: {printf("B1-9 %d\n",jchar[7]); break;}
					case 2: {printf("B1-10 %d\n",jchar[7]); break;}
					case 4: {printf("B1-11 %d\n",jchar[7]); break;}
					case 8: {printf("B1-12 %d\n",jchar[7]); break;}
				}
				BBprev = jchar[7];
			} else if ((jchar[7] == 0) && (jchar[7] != BBprev)) {printf("\t%d Base Button goes off %d.\n",BBprev, jchar[7]); BBprev = jchar[7];}
*
		} // end of jres if
    }
//printf(" SELF Exited \n");
	return NULL;

}		// -----  end of function js1_thread  ----- 
*/
